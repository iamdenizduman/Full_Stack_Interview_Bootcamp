ACID Prensipleri
--
Atomicity (Bölünemezlik): Transaction içindeki tüm adımlar ya tamamı başarılı olur ya da hiçbirisi uygulanmaz. Örneğin para transferinde para çekme başarılı ama yatırma başarısız olursa tüm işlem geri alınır.

Consistency (Tutarlılık): Transaction öncesi ve sonrası sistemin kurallarına göre tutarlı bir durumda kalması gerekir. Örneğin hesap bakiyeleri toplamı işlem öncesi ve sonrası aynı olmalı.

Isolation (Yalıtım): Aynı anda çalışan transaction’lar birbirini etkilemeden çalışmalıdır. Yani bir işlem bitmeden başka bir işlem onun ara verilerini görmemeli.

Durability (Kalıcılık): Transaction başarılı bir şekilde tamamlandıktan sonra, sistem çökse bile bu değişiklikler kalıcı olur. Genelde veriler diske yazılarak sağlanır.


Isolation Level
--
Read Uncommitted: Başka transaction’ların henüz commit edilmemiş verilerini okuyabilir.

Read Committed: Yalnızca commit edilmiş verileri okuyabilir.

RepeatableRead: Aynı anda çalışan iki client'tan biri savechanges'a geldiğinde commit olana kadar diğer transaction kitlenir. Bu sayede bir tık daha veri tutarlı hale gelir.

RepeatableRead'e ek olarak tutarlılık sağlamak için select sorgusuna UPDLOCK, ROWLOCK gibi kilit getirir aynı anda ikinci bir transaction bu satırı okuyamaz bekler. Böylece iki transaction yarışa girmez (race conditions) biri biter diğeri sonra başlar.

Ek olarak ikinci yöntem tabloya RowVersion kolonu eklenmesi (timestamp), transaction sonunda ef core satırın versiyonunun değişip değişmediğini kontrol eder. Değiştiyse hata(DbUpdateConcurrencyException) fırlatır işlem retry edilir veya iptal edilir.


EfCore
-- 
ACID_EFCore projesi altında isolation seviyelerini değerlendirdik.


Idempotency
--
Idempotency (idempotentlik), bir işlem veya API isteği birden fazla kez yapıldığında, aynı sonucu döndürmesi, yani işlemin sonucunun değişmemesi özelliğidir. Bir işlem ilk kez başarılı bir şekilde çalıştırıldığında, aynı işlem tekrar yapıldığında aynı sonuca ulaşılmalıdır. Bu, özellikle ağ hataları, yeniden gönderilen istekler (duplicate requests) gibi durumlarda önemlidir.

Örneğin; Her para transferi için benzersiz bir işlem kimliği (idempotency key) oluşturulabilir.İstemci, bu işlem kimliğini gönderir ve sunucu bu kimliği kontrol eder. Aynı işlem kimliğiyle gelen bir istek, zaten tamamlanmış bir işlemle sonuçlanmaz.Bu işlem tamamlanmışsa, sunucu zaten yapılan işlemi tekrar yapmaz, başarıyla sonuçlanan bir yanıt döner.İstemciden gelen işlem kimliği, veritabanında saklanır.İşlem tamamlandığında bu işlem kimliği ile birlikte, işlem sonucu ve durumu kaydedilir.Aynı işlem kimliğiyle gelen ikinci istek, sadece mevcut işlemin sonucunu geri döndürür.

Özetle; Idempotency uygulaması, bankacılık sistemlerinde kullanıcıları hatalardan korur ve veri tutarlılığını sağlar. Özellikle duplicate transaction’lar gibi hatalar, idempotent işlemlerle önlenebilir.


Para Transferi gibi kritik yüksek trafikli bir API tasarlarken nelere dikkat edilmelidir?
--
Temel olarak 4 hedef önceliklidir; Veri tutarlılığı, Yüksek erişilebilirlik (kesintisiz çalışma), Ölçeklenebilirlik (aynı anda bir çok kullanıcının işlem yapmasına olanak sağlama), Performans (hızlı yanıt süreleri)

Yüksek trafike ve performans için çözümler;
- Load Balancer: API Gateway ya da Nginx gibi sistemlerle gelen yük eşit dağıtılır. Horizontal scaling yapılır (birden fazla instance).
- Read-Write Separation: Okuma işlemleri için read replica kullanılır (örneğin sadece bakiyeye bakmak). Yazma işlemleri için master DB kullanılır.
- Queue Tabanlı İşlem Yönetimi: Para transferi işlemi doğrudan DB’ye yazılmaz, önce bir queue’ya (Kafka, RabbitMQ) bırakılır. Arka plandaki worker bunu işler → böylece sistem daha hızlı yanıt verir.
- Idempotency: İşlem tekrar gönderilirse sorun olmaz 
- Dağıtık Kilitleme: Redis ile SETNX lock_account_123 şeklinde lock alarak aynı anda birden fazla çekim işlemi engellenir.
- Eventual Consistency yerine Strong Consistency: Para transferi gibi kritik sistemlerde çoğunlukla strong consistency tercih edilir. Bu nedenle transaction yönetimi dikkatli yapılır: BeginTransaction, Commit, Rollback.

Ekstra önlemler;
- Retry Mechanism: İşlem başarısızsa belirli sayıda tekrar edilir.
- Dead Letter Queue (DLQ): Queue'da sürekli hata veren işler DLQ'ya atılır, sonra incelenir.
- Audit Log: Hangi kullanıcının ne zaman ne yaptığı izlenebilir olmalı.
- Monitoring / Alerting: Prometheus, Grafana, ELK stack gibi araçlarla sistem izlenir.


Özetle;
- Mikroservis mimarisi tercih edilmeli.
- Queue tabanlı asenkron mimari kullanılmalı.
- Idempotency ve distributed locking gibi veri tutarlılığını sağlayan mekanizmalar kullanılmalı.
- Strong consistency önemli olduğu için transaction’lar dikkatle yönetilmeli.
- Ölçeklenebilirlik için replica, cache, load balancer, queue gibi bileşenler eklenmeli.

Eventual Consistency (Nihai Tutarlılık)
--
Eventual consistency, dağıtık sistemlerde tüm node’ların zaman içinde (hemen değil) aynı veri durumuna ulaşacağını garanti eden bir tutarlılık modelidir. Bazı yan hizmetlerde eventual consistency olabilir. Örneğin:
SMS bildirim gönderimi, Push notification, Loglama

Distributed Transaction (Dağıtık İşlem)
--
Distributed Transaction, birden fazla farklı kaynağa (veritabanı, servis, mesaj kuyruğu, vb.) aynı anda yazma yapılması gereken durumlarda, bu işlemlerin tamamının ya başarılı ya da tamamen başarısız olmasını garanti altına alan bir yapıdır. (Klasik “ACID” prensiplerinin çoklu sistemler arasında da geçerli olmasını sağlamaya çalışır.)
Yaklaşımlar;
Klasik yaklaşım: 2-Phase Commit(2PC)
- Prepare ve Commit aşamalarından oluşur, tüm katılımcılara işlem yapabilirim der ve herkes hazırsa commit edilir, biri hata verirse rollback yapılır.
- Performans düşüktür.Blocking olur (kilitlenir).Modern sistemlerde (microservice) önerilmez!

Modern yaklaşım: 
Saga Pattern
- Birden çok servis kendi local transaction’ını yapar, ve event'lerle bir sonrakine haber verir.Eğer bir adım başarısız olursa, önceki adımların “compensating transaction” ile geri alınması gerekir.
 Outbox Pattern
 - Uygulama, DB’ye veriyi yazar ve aynı transaction içinde bir "Outbox" tablosuna event kaydeder. Event daha sonra ayrı bir servis tarafından publish edilir.Bu sayede veri ve event tutarlılığı sağlanır.









